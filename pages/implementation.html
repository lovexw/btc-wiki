<div class="page-content">
    <button class="back-button" onclick="goHome()"><i class="fas fa-arrow-left"></i> 返回首页</button>
    
    <h2>比特币实现细节与源码解析</h2>
    
    <h3>1. Bitcoin Core概述</h3>
    
    <p>Bitcoin Core是比特币的参考实现，用<strong>C++</strong>编写，是最广泛使用的全节点软件。</p>
    
    <h4>1.1 核心组件</h4>
    <ul>
        <li><strong>bitcoind</strong>：守护进程，运行全节点</li>
        <li><strong>bitcoin-cli</strong>：命令行工具</li>
        <li><strong>bitcoin-qt</strong>：图形界面钱包</li>
        <li><strong>bitcoin-tx</strong>：交易工具</li>
    </ul>
    
    <h4>1.2 代码结构</h4>
    <pre><code>src/
├── consensus/      # 共识规则
├── crypto/         # 密码学实现
├── net/            # 网络层
├── wallet/         # 钱包功能
├── rpc/            # RPC接口
├── script/         # 脚本解释器
├── validation.cpp  # 交易和区块验证
├── miner.cpp       # 挖矿逻辑
└── chainparams.cpp # 链参数配置</code></pre>
    
    <h3>2. 数据存储</h3>
    
    <h4>2.1 LevelDB数据库</h4>
    <p>Bitcoin Core使用LevelDB存储区块链索引和UTXO集：</p>
    
    <pre><code>数据目录结构（~/.bitcoin/）：
├── blocks/
│   ├── blk*.dat     # 原始区块数据
│   ├── rev*.dat     # 撤销数据（用于重组）
│   └── index/       # 区块索引（LevelDB）
├── chainstate/      # UTXO集（LevelDB）
├── wallet.dat       # 钱包数据（BerkeleyDB）
└── debug.log        # 日志文件</code></pre>
    
    <h4>2.2 区块文件格式</h4>
    <pre><code>blk*.dat文件：
[Magic Bytes: 4 bytes]  # 0xD9B4BEF9（主网）
[Size: 4 bytes]         # 区块大小
[Block Data]            # 完整区块

多个区块顺序存储在同一文件中
每个文件最大128MB</code></pre>
    
    <h4>2.3 UTXO集存储</h4>
    <pre><code>chainstate/ 数据库存储：
Key: txid + vout
Value: 
  - 区块高度
  - 是否coinbase
  - 金额
  - scriptPubKey

优化：
- 压缩存储
- 内存缓存
- 增量更新</code></pre>
    
    <h3>3. 交易验证实现</h3>
    
    <h4>3.1 验证流程代码（简化）</h4>
    <pre><code>// validation.cpp

bool CheckTransaction(const CTransaction& tx) {
    // 基本检查
    if (tx.vin.empty()) return false;
    if (tx.vout.empty()) return false;
    
    // 检查输出金额
    CAmount nValueOut = 0;
    for (const auto& txout : tx.vout) {
        if (txout.nValue < 0) return false;
        if (txout.nValue > MAX_MONEY) return false;
        nValueOut += txout.nValue;
        if (nValueOut > MAX_MONEY) return false;
    }
    
    // 检查输入重复
    std::set<COutPoint> vInOutPoints;
    for (const auto& txin : tx.vin) {
        if (!vInOutPoints.insert(txin.prevout).second)
            return false;  // 重复输入
    }
    
    return true;
}

bool CheckInputs(const CTransaction& tx, CCoinsViewCache& inputs) {
    // 验证每个输入
    for (unsigned int i = 0; i < tx.vin.size(); i++) {
        const COutPoint& prevout = tx.vin[i].prevout;
        const Coin& coin = inputs.AccessCoin(prevout);
        
        // 检查UTXO存在
        if (coin.IsSpent()) return false;
        
        // 执行脚本验证
        ScriptError serror;
        if (!VerifyScript(tx.vin[i].scriptSig, 
                          coin.out.scriptPubKey,
                          &tx, i, 
                          STANDARD_SCRIPT_VERIFY_FLAGS,
                          &serror)) {
            return false;
        }
    }
    
    // 验证费用
    CAmount nFees = 0;
    if (!Consensus::CheckTxInputs(tx, state, inputs, 
                                   nSpendHeight, nFees)) {
        return false;
    }
    
    return true;
}</code></pre>
    
    <h4>3.2 脚本执行引擎</h4>
    <pre><code>// script/interpreter.cpp

bool EvalScript(stack<valtype>& stack, const CScript& script) {
    auto pc = script.begin();
    while (pc < script.end()) {
        opcodetype opcode;
        valtype vchPushValue;
        
        // 读取操作码
        if (!script.GetOp(pc, opcode, vchPushValue))
            return false;
        
        // 执行操作
        switch (opcode) {
            case OP_DUP:
                if (stack.size() < 1) return false;
                stack.push(stack.top());
                break;
                
            case OP_HASH160:
                if (stack.size() < 1) return false;
                valtype& vch = stack.top();
                stack.top() = Hash160(vch);
                break;
                
            case OP_CHECKSIG:
                // 验证签名
                if (stack.size() < 2) return false;
                valtype& vchSig = stack.top();
                valtype& vchPubKey = stack.top(-1);
                
                bool fSuccess = CheckSig(vchSig, vchPubKey, 
                                         script, txTo, nIn);
                stack.pop();
                stack.pop();
                stack.push(fSuccess ? vchTrue : vchFalse);
                break;
                
            // ... 其他操作码
        }
    }
    
    return !stack.empty() && CastToBool(stack.top());
}</code></pre>
    
    <h3>4. 挖矿实现</h3>
    
    <h4>4.1 区块模板构建</h4>
    <pre><code>// miner.cpp

std::unique_ptr<CBlockTemplate> 
BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn) {
    // 创建空区块
    auto pblocktemplate = std::make_unique<CBlockTemplate>();
    CBlock* pblock = &pblocktemplate->block;
    
    // 添加Coinbase交易
    CMutableTransaction coinbaseTx;
    coinbaseTx.vin.resize(1);
    coinbaseTx.vin[0].prevout.SetNull();
    coinbaseTx.vout.resize(1);
    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;
    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight);
    pblock->vtx[0] = MakeTransactionRef(coinbaseTx);
    
    // 从内存池选择交易
    addPackageTxs(nPackagesSelected, nDescendantsUpdated);
    
    // 填充区块头
    pblock->nVersion = computeBlockVersion();
    pblock->nTime = GetAdjustedTime();
    pblock->hashPrevBlock = chainActive.Tip()->GetBlockHash();
    pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);
    pblock->nBits = GetNextWorkRequired(pindexPrev);
    pblock->nNonce = 0;
    
    return pblocktemplate;
}</code></pre>
    
    <h4>4.2 挖矿循环</h4>
    <pre><code>// 挖矿主循环（简化）

void BitcoinMiner(CWallet* pwallet) {
    while (true) {
        // 创建新区块
        auto pblocktemplate = BlockAssembler().CreateNewBlock(scriptPubKey);
        CBlock* pblock = &pblocktemplate->block;
        
        // 挖矿循环
        uint256 hashTarget = uint256().SetCompact(pblock->nBits);
        while (true) {
            // 计算哈希
            uint256 hash = pblock->GetHash();
            
            // 检查是否满足难度
            if (hash <= hashTarget) {
                // 找到有效区块！
                ProcessNewBlock(pblock);
                break;
            }
            
            // 增加Nonce
            pblock->nNonce++;
            
            // Nonce溢出，更新时间或extraNonce
            if (pblock->nNonce == 0) {
                pblock->nTime++;
                // 或更新Coinbase的extraNonce
            }
            
            // 定期检查新交易和区块
            if (pblock->nNonce % 1000 == 0) {
                if (新区块到来) break;  // 重新开始
            }
        }
    }
}</code></pre>
    
    <h3>5. P2P网络实现</h3>
    
    <h4>5.1 节点连接管理</h4>
    <pre><code>// net.cpp

class CNode {
    CCriticalSection cs_vSend;
    std::deque<CSerializeData> vSendMsg;
    
    // 发送消息
    void PushMessage(const char* pszCommand, ...) {
        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);
        // 序列化消息
        BeginMessage(ss, pszCommand);
        // 写入数据
        EndMessage(ss);
        
        // 加入发送队列
        vSendMsg.push_back(ss);
    }
};

// 消息处理循环
void ProcessMessages(CNode* pfrom) {
    while (!pfrom->vRecvMsg.empty()) {
        CNetMessage& msg = pfrom->vRecvMsg.front();
        
        // 解析消息头
        CMessageHeader hdr;
        msg.vRecv >> hdr;
        
        // 分发到对应处理函数
        if (hdr.command == "version")
            ProcessVersionMessage(pfrom, msg);
        else if (hdr.command == "inv")
            ProcessInvMessage(pfrom, msg);
        else if (hdr.command == "getdata")
            ProcessGetDataMessage(pfrom, msg);
        // ... 其他消息类型
        
        pfrom->vRecvMsg.pop_front();
    }
}</code></pre>
    
    <h3>6. RPC接口</h3>
    
    <h4>6.1 常用RPC命令</h4>
    <pre><code>// 区块链信息
bitcoin-cli getblockchaininfo
bitcoin-cli getblock <blockhash>
bitcoin-cli gettransaction <txid>

// 钱包操作
bitcoin-cli getnewaddress
bitcoin-cli sendtoaddress <address> <amount>
bitcoin-cli getbalance

// 网络信息
bitcoin-cli getpeerinfo
bitcoin-cli getnetworkinfo

// 挖矿（测试网）
bitcoin-cli generatetoaddress <nblocks> <address></code></pre>
    
    <h4>6.2 RPC实现示例</h4>
    <pre><code>// rpc/blockchain.cpp

UniValue getblock(const JSONRPCRequest& request) {
    // 解析参数
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    int verbosity = 1;
    if (!request.params[1].isNull())
        verbosity = request.params[1].get_int();
    
    // 查找区块
    CBlockIndex* pblockindex = LookupBlockIndex(hash);
    if (!pblockindex)
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, 
                           "Block not found");
    
    // 读取区块数据
    CBlock block;
    if (!ReadBlockFromDisk(block, pblockindex))
        throw JSONRPCError(RPC_MISC_ERROR, 
                           "Can't read block from disk");
    
    // 返回JSON
    if (verbosity <= 0)
        return HexStr(block);
    
    UniValue result(UniValue::VOBJ);
    result.pushKV("hash", pblockindex->GetBlockHash().GetHex());
    result.pushKV("height", pblockindex->nHeight);
    result.pushKV("version", block.nVersion);
    result.pushKV("merkleroot", block.hashMerkleRoot.GetHex());
    // ... 更多字段
    
    return result;
}</code></pre>
    
    <h3>7. 性能优化</h3>
    
    <h4>7.1 签名缓存</h4>
    <p>已验证的签名会被缓存，避免重复验证：</p>
    <pre><code>CuckooCache::cache<uint256> scriptExecutionCache;</code></pre>
    
    <h4>7.2 并行验证</h4>
    <p>使用多线程并行验证区块中的交易。</p>
    
    <h4>7.3 UTXO缓存</h4>
    <p>内存中缓存频繁访问的UTXO，减少磁盘I/O。</p>
    
    <h3>8. 测试框架</h3>
    
    <h4>8.1 单元测试</h4>
    <pre><code>// src/test/

BOOST_AUTO_TEST_CASE(script_standard_push) {
    // 测试脚本pushdata操作
    for (int i = -1; i < 1000; i++) {
        CScript script;
        script << i;
        BOOST_CHECK(script.IsPushOnly());
    }
}</code></pre>
    
    <h4>8.2 回归测试</h4>
    <p>Python编写的功能测试，模拟完整的节点交互。</p>
    
    <h3>9. 编译与运行</h3>
    
    <pre><code># 编译Bitcoin Core（Linux）

# 安装依赖
sudo apt-get install build-essential libtool autotools-dev \
    automake pkg-config bsdmainutils python3 libssl-dev \
    libevent-dev libboost-all-dev libdb++-dev

# 克隆源码
git clone https://github.com/bitcoin/bitcoin.git
cd bitcoin

# 编译
./autogen.sh
./configure
make -j$(nproc)
make install

# 运行
bitcoind -daemon

# 测试
bitcoin-cli getblockchaininfo</code></pre>
    
    <h3>10. 总结</h3>
    
    <div class="success-box">
        <h4>核心要点</h4>
        <ul>
            <li><strong>C++实现</strong>：高性能、跨平台</li>
            <li><strong>LevelDB存储</strong>：高效的键值数据库</li>
            <li><strong>模块化设计</strong>：清晰的代码结构</li>
            <li><strong>RPC接口</strong>：便于集成和自动化</li>
            <li><strong>性能优化</strong>：缓存、并行、压缩</li>
            <li><strong>测试覆盖</strong>：单元测试和功能测试</li>
        </ul>
    </div>
    
    <p>Bitcoin Core是开源项目，任何人都可以查看源码、提交改进。理解实现细节有助于深入掌握比特币的工作原理。</p>
    
    <button class="back-button" onclick="goHome()"><i class="fas fa-arrow-left"></i> 返回首页</button>
</div>
