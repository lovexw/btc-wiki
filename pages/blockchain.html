<div class="page-content">
    <button class="back-button" onclick="goHome()"><i class="fas fa-arrow-left"></i> 返回首页</button>
    
    <h2>区块链技术详解</h2>
    
    <h3>1. 区块链概述</h3>
    
    <h4>1.1 什么是区块链？</h4>
    <p>区块链（Blockchain）是一种特殊的数据结构，它由一系列按时间顺序排列的<strong>区块（Block）</strong>通过密码学方法链接形成的<strong>链（Chain）</strong>。每个区块包含一批交易记录，并通过哈希指针连接到前一个区块。</p>
    
    <div class="info-box">
        <h4>通俗理解</h4>
        <p>想象一个账本，每一页记录一段时间内的交易，页与页之间用特殊的"锁链"连接。每一页都包含上一页的"指纹"（哈希值），这样如果有人想篡改前面的某一页，后面所有页的"指纹"都会对不上，篡改会立即被发现。</p>
    </div>
    
    <h4>1.2 为什么需要区块链？</h4>
    <p>区块链解决了分布式系统中的关键问题：</p>
    <ul>
        <li><strong>数据一致性</strong>：确保所有节点看到相同的数据</li>
        <li><strong>防篡改</strong>：历史记录一旦写入就难以修改</li>
        <li><strong>可追溯</strong>：可以回溯到任意历史状态</li>
        <li><strong>去信任</strong>：不需要信任任何单一节点</li>
    </ul>
    
    <h3>2. 区块的结构</h3>
    
    <h4>2.1 区块的组成部分</h4>
    <p>一个比特币区块由两部分组成：</p>
    
    <div class="example-box">
        <h4>区块结构</h4>
        <pre><code>区块
├── 区块头（Block Header）- 80字节
│   ├── 版本号（Version）- 4字节
│   ├── 前一区块哈希（Previous Block Hash）- 32字节
│   ├── 默克尔根（Merkle Root）- 32字节
│   ├── 时间戳（Timestamp）- 4字节
│   ├── 难度目标（Bits）- 4字节
│   └── 随机数（Nonce）- 4字节
└── 交易列表（Transactions）- 可变大小
    ├── 交易计数器
    └── 交易数据</code></pre>
    </div>
    
    <h4>2.2 区块头详解</h4>
    
    <p><strong>① 版本号（Version）</strong></p>
    <p>指示该区块遵循的验证规则版本。随着比特币协议升级，版本号会更新。</p>
    
    <p><strong>② 前一区块哈希（Previous Block Hash）</strong></p>
    <p>这是区块链的核心！每个区块都包含前一个区块头的SHA-256哈希值，这样区块就像链条一样连接起来。</p>
    
    <div class="info-box">
        <h4>链式结构的威力</h4>
        <p>假设你想修改区块100的某笔交易：</p>
        <ol>
            <li>修改区块100的交易后，其默克尔根会改变</li>
            <li>默克尔根改变导致区块100的哈希值改变</li>
            <li>区块101包含区块100的哈希，现在对不上了</li>
            <li>你必须重新计算区块101的Nonce（需要大量算力）</li>
            <li>区块101改变后，区块102又对不上了</li>
            <li>你需要重新计算102、103...一直到最新区块</li>
            <li>而网络还在持续产生新区块，你永远追不上！</li>
        </ol>
        <p>这就是为什么说区块链"不可篡改"——技术上可以改，但成本极高，几乎不可行。</p>
    </div>
    
    <p><strong>③ 默克尔根（Merkle Root）</strong></p>
    <p>区块中所有交易的"指纹"。默克尔树是一种特殊的哈希树结构，能够高效地验证某笔交易是否在区块中。</p>
    
    <div class="example-box">
        <h4>默克尔树工作原理</h4>
        <pre><code>假设区块有4笔交易：Tx1, Tx2, Tx3, Tx4

第一层（叶子节点）：
Hash1 = Hash(Tx1)
Hash2 = Hash(Tx2)
Hash3 = Hash(Tx3)
Hash4 = Hash(Tx4)

第二层：
Hash12 = Hash(Hash1 + Hash2)
Hash34 = Hash(Hash3 + Hash4)

第三层（默克尔根）：
Merkle Root = Hash(Hash12 + Hash34)</code></pre>
        
        <p>这样，只需要32字节的默克尔根，就能代表区块中所有交易的摘要。如果任何一笔交易被修改，默克尔根会完全不同。</p>
    </div>
    
    <p><strong>④ 时间戳（Timestamp）</strong></p>
    <p>区块创建的大致时间（Unix时间戳），不需要非常精确。主要用途：</p>
    <ul>
        <li>确定区块的顺序</li>
        <li>计算难度调整</li>
        <li>防止时间戳攻击</li>
    </ul>
    
    <p><strong>⑤ 难度目标（Bits）</strong></p>
    <p>挖矿难度的压缩表示。区块的哈希值必须小于这个目标值才被认为有效。</p>
    
    <div class="example-box">
        <h4>难度目标示例</h4>
        <p>假设难度目标是：</p>
        <code>0000000000000000000f2a00000000000000000000000000000000000000000</code>
        <p>矿工必须找到一个Nonce，使得区块头的哈希值小于这个目标。前面的零越多，难度越大。</p>
    </div>
    
    <p><strong>⑥ 随机数（Nonce）</strong></p>
    <p>Nonce是"Number used once"的缩写。矿工不断尝试不同的Nonce值，直到找到一个使区块哈希满足难度要求的值。</p>
    
    <h3>3. 交易在区块中的存储</h3>
    
    <h4>3.1 区块大小限制</h4>
    <p>比特币最初设定每个区块最大<strong>1MB</strong>（SegWit后理论上可以达到约4MB）。这限制了每个区块能包含的交易数量，大约：</p>
    <ul>
        <li>简单交易：约2000-2500笔/区块</li>
        <li>复杂交易：可能只有几百笔</li>
    </ul>
    
    <h4>3.2 交易选择策略</h4>
    <p>由于区块空间有限，矿工会优先选择：</p>
    <ul>
        <li><strong>手续费高的交易</strong>：矿工的收入来源</li>
        <li><strong>体积小的交易</strong>：可以塞进更多交易</li>
        <li>实际选择标准：<strong>每字节手续费</strong>（satoshi/byte）</li>
    </ul>
    
    <h3>4. 创世区块</h3>
    
    <h4>4.1 特殊的第一个区块</h4>
    <p>创世区块（Genesis Block）是比特币区块链的第一个区块，具有特殊性：</p>
    
    <div class="info-box">
        <h4>创世区块信息</h4>
        <ul>
            <li><strong>区块高度</strong>：0</li>
            <li><strong>区块哈希</strong>：000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</li>
            <li><strong>时间戳</strong>：2009-01-03 18:15:05</li>
            <li><strong>Coinbase文本</strong>："The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"</li>
            <li><strong>区块奖励</strong>：50 BTC（永远无法使用，可能是代码bug）</li>
        </ul>
    </div>
    
    <h4>4.2 硬编码在代码中</h4>
    <p>创世区块是硬编码在比特币客户端代码中的，每个节点启动时都会从创世区块开始同步：</p>
    
    <pre><code>// Bitcoin Core 源码中的创世区块定义
const uint256 hashGenesisBlock = uint256S(
    "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"
);</code></pre>
    
    <h3>5. 区块的生成过程</h3>
    
    <h4>5.1 完整流程</h4>
    
    <div class="example-box">
        <h4>矿工产生新区块的步骤</h4>
        <ol>
            <li><strong>监听交易</strong>：从内存池（Mempool）中选择待确认的交易</li>
            <li><strong>验证交易</strong>：确保每笔交易都有效（签名正确、没有双花等）</li>
            <li><strong>构建默克尔树</strong>：将所有交易组织成默克尔树结构</li>
            <li><strong>创建Coinbase交易</strong>：第一笔交易是矿工的奖励</li>
            <li><strong>组装区块头</strong>：
                <ul>
                    <li>设置版本号</li>
                    <li>引用前一区块哈希</li>
                    <li>计算默克尔根</li>
                    <li>记录时间戳</li>
                    <li>设置难度目标</li>
                    <li>Nonce从0开始</li>
                </ul>
            </li>
            <li><strong>挖矿</strong>：不断尝试不同的Nonce，计算区块哈希</li>
            <li><strong>验证</strong>：当找到符合难度的哈希时，检查区块是否有效</li>
            <li><strong>广播</strong>：向网络中的其他节点广播新区块</li>
        </ol>
    </div>
    
    <h4>5.2 区块哈希的计算</h4>
    
    <pre><code>// 区块哈希的计算过程（伪代码）

function calculateBlockHash(blockHeader) {
    // 序列化区块头（80字节）
    data = serialize(
        version,           // 4 bytes
        previousHash,      // 32 bytes
        merkleRoot,        // 32 bytes
        timestamp,         // 4 bytes
        bits,              // 4 bytes
        nonce              // 4 bytes
    )
    
    // 双重SHA-256哈希
    hash1 = SHA256(data)
    hash2 = SHA256(hash1)
    
    return hash2
}

// 挖矿过程
function mine(blockHeader, target) {
    nonce = 0
    while (true) {
        blockHeader.nonce = nonce
        hash = calculateBlockHash(blockHeader)
        
        if (hash < target) {
            // 找到有效区块！
            return blockHeader
        }
        
        nonce++
        
        // 如果nonce用完（2^32），需要改变其他参数
        if (nonce > 0xFFFFFFFF) {
            // 更新时间戳或Coinbase的extraNonce
            resetNonce()
        }
    }
}</code></pre>
    
    <h3>6. 区块的传播与验证</h3>
    
    <h4>6.1 新区块的传播</h4>
    <p>当矿工找到新区块后：</p>
    
    <ol>
        <li><strong>立即停止当前工作</strong>：开始在新区块基础上挖下一个区块</li>
        <li><strong>向邻近节点广播</strong>：通过P2P网络传播</li>
        <li><strong>节点接收并验证</strong>：每个节点独立验证区块的有效性</li>
        <li><strong>继续传播</strong>：验证通过后转发给其他节点</li>
    </ol>
    
    <div class="info-box">
        <h4>区块传播优化</h4>
        <p>为了加速传播，比特币网络使用了多种优化技术：</p>
        <ul>
            <li><strong>Compact Block</strong>：只传输交易ID，节点从本地内存池重建完整区块</li>
            <li><strong>Fast Relay Network</strong>：专门的高速中继网络</li>
            <li><strong>FIBRE</strong>：快速互联网比特币中继引擎</li>
        </ul>
    </div>
    
    <h4>6.2 区块验证规则</h4>
    <p>节点收到新区块后，会执行严格的验证：</p>
    
    <div class="example-box">
        <h4>区块验证检查清单</h4>
        <ol>
            <li><strong>结构验证</strong>：
                <ul>
                    <li>区块大小不超过限制</li>
                    <li>区块头格式正确</li>
                    <li>至少包含一笔交易（Coinbase）</li>
                </ul>
            </li>
            <li><strong>哈希验证</strong>：
                <ul>
                    <li>区块哈希满足难度要求</li>
                    <li>区块哈希计算正确</li>
                </ul>
            </li>
            <li><strong>前向引用验证</strong>：
                <ul>
                    <li>前一区块哈希正确</li>
                    <li>能够连接到已知的区块链</li>
                </ul>
            </li>
            <li><strong>时间戳验证</strong>：
                <ul>
                    <li>时间戳不能太久远（不超过2小时）</li>
                    <li>时间戳必须大于前11个区块时间的中位数</li>
                </ul>
            </li>
            <li><strong>Coinbase验证</strong>：
                <ul>
                    <li>第一笔交易是Coinbase</li>
                    <li>Coinbase奖励正确（区块奖励 + 交易费）</li>
                    <li>Coinbase成熟度规则（100个区块后才能使用）</li>
                </ul>
            </li>
            <li><strong>交易验证</strong>：
                <ul>
                    <li>所有交易格式正确</li>
                    <li>没有重复交易</li>
                    <li>每笔交易都通过独立验证</li>
                    <li>默克尔根匹配</li>
                </ul>
            </li>
        </ol>
    </div>
    
    <h3>7. 孤块与叔块</h3>
    
    <h4>7.1 孤块（Orphan Block）</h4>
    <p>孤块是指节点收到的区块，但其父区块（previous block）尚未收到的区块。</p>
    
    <div class="example-box">
        <h4>孤块场景</h4>
        <p>假设节点的区块链到区块100，突然收到区块102。因为缺少区块101，区块102无法连接到链上，暂时成为孤块。</p>
        <p>节点会：</p>
        <ul>
            <li>暂时保存孤块</li>
            <li>请求缺失的区块101</li>
            <li>收到101后，将102连接上</li>
        </ul>
    </div>
    
    <h4>7.2 过时块/叔块（Stale Block）</h4>
    <p>当两个矿工几乎同时找到有效区块时，网络会暂时出现分叉。最终较短的分支会被放弃，其上的区块称为过时块。</p>
    
    <div class="info-box">
        <h4>分叉解决</h4>
        <pre><code>场景：
- 矿工A找到区块100A
- 矿工B同时找到区块100B
- 网络一部分收到100A，一部分收到100B
- 暂时有两个版本的链

解决：
- 矿工C在100A基础上找到101C
- 现在"100A-101C"链更长
- 所有节点切换到更长的链
- 100B成为过时块，被丢弃
- 100B中的交易返回内存池，等待重新确认</code></pre>
    </div>
    
    <h3>8. 区块高度与区块链长度</h3>
    
    <h4>8.1 区块高度</h4>
    <p>区块高度是指区块在区块链中的位置：</p>
    <ul>
        <li>创世区块：高度0</li>
        <li>第二个区块：高度1</li>
        <li>以此类推...</li>
    </ul>
    
    <h4>8.2 链的选择</h4>
    <p>比特币使用<strong>最长链规则</strong>（更准确说是<strong>最大工作量链</strong>）：</p>
    
    <div class="info-box">
        <h4>为什么是"最大工作量"而非"最长"？</h4>
        <p>实际上，比特币选择的是累积工作量最大的链，而不是简单的区块数量最多的链。因为不同区块的难度可能不同，所以：</p>
        <code>链的工作量 = Σ(每个区块的难度)</code>
        <p>大多数情况下，最长链就是工作量最大的链，但在难度调整期可能有细微差异。</p>
    </div>
    
    <h3>9. 区块链的存储</h3>
    
    <h4>9.1 存储结构</h4>
    <p>Bitcoin Core使用LevelDB数据库存储区块链数据，主要文件包括：</p>
    
    <div class="table-container">
        <table>
            <thead>
                <tr>
                    <th>文件/目录</th>
                    <th>内容</th>
                    <th>用途</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>blocks/blk*.dat</td>
                    <td>原始区块数据</td>
                    <td>存储完整的区块</td>
                </tr>
                <tr>
                    <td>blocks/rev*.dat</td>
                    <td>撤销数据</td>
                    <td>用于回滚区块链</td>
                </tr>
                <tr>
                    <td>blocks/index/</td>
                    <td>区块索引</td>
                    <td>LevelDB，快速查找区块</td>
                </tr>
                <tr>
                    <td>chainstate/</td>
                    <td>UTXO集合</td>
                    <td>当前所有未花费输出</td>
                </tr>
            </tbody>
        </table>
    </div>
    
    <h4>9.2 存储大小</h4>
    <p>截至2024年：</p>
    <ul>
        <li><strong>完整区块链</strong>：约500-600 GB</li>
        <li><strong>UTXO集</strong>：约5-6 GB</li>
        <li><strong>每年增长</strong>：约50-60 GB</li>
    </ul>
    
    <h4>9.3 修剪模式（Pruning）</h4>
    <p>为了节省存储空间，节点可以运行在修剪模式：</p>
    <ul>
        <li>只保留最近的区块（例如最近550个区块）</li>
        <li>保留完整的UTXO集</li>
        <li>可以验证新区块，但无法为其他节点提供历史数据</li>
        <li>最小配置可以将存储需求降低到约10GB</li>
    </ul>
    
    <h3>10. 特殊的区块</h3>
    
    <h4>10.1 检查点区块（Checkpoint）</h4>
    <p>检查点是硬编码在客户端中的某些区块哈希，用于：</p>
    <ul>
        <li>防止重组攻击</li>
        <li>加速初始同步</li>
        <li>提供确定性的区块链历史</li>
    </ul>
    
    <h4>10.2 信号区块（Signaling Block）</h4>
    <p>矿工通过区块头的版本字段或Coinbase信号支持某个升级提案（BIP）。例如：</p>
    <ul>
        <li>BIP 9：版本位信号</li>
        <li>BIP 91：SegWit激活信号</li>
        <li>Taproot激活：Speedy Trial机制</li>
    </ul>
    
    <h3>11. 区块链重组（Reorganization）</h3>
    
    <h4>11.1 什么是重组？</h4>
    <p>当节点发现一条更长（更大工作量）的链时，会放弃当前链，切换到新链。被放弃的区块中的交易会回到内存池。</p>
    
    <div class="warning-box">
        <h4><i class="fas fa-exclamation-triangle"></i> 重组风险</h4>
        <p>这就是为什么比特币交易需要等待多个确认：</p>
        <ul>
            <li><strong>1个确认</strong>：交易在最新区块中，但可能被重组</li>
            <li><strong>6个确认</strong>：交易在6个区块之前，重组概率极低（行业标准）</li>
            <li><strong>100个确认</strong>：Coinbase交易必须等待的确认数</li>
        </ul>
        <p>重组深度越深，需要的算力越大，所以深度重组几乎不会自然发生（除非遭到51%攻击）。</p>
    </div>
    
    <h4>11.2 重组场景</h4>
    
    <pre><code>初始状态：
主链: A -> B -> C -> D -> E
分叉: A -> B -> X

新区块到来：
主链: A -> B -> C -> D -> E
分叉: A -> B -> X -> Y -> Z -> W (更长！)

发生重组：
新主链: A -> B -> X -> Y -> Z -> W
被放弃: C -> D -> E (这些区块中的交易重新进入内存池)</code></pre>
    
    <h3>12. 轻节点的简化验证</h3>
    
    <h4>12.1 SPV（简化支付验证）</h4>
    <p>轻节点不下载完整区块，只下载区块头（每个80字节）：</p>
    
    <div class="info-box">
        <h4>SPV验证过程</h4>
        <ol>
            <li>下载所有区块头（约70MB）</li>
            <li>验证工作量证明链</li>
            <li>当需要验证某笔交易时：
                <ul>
                    <li>向全节点请求该交易的默克尔路径</li>
                    <li>通过默克尔路径验证交易在区块中</li>
                    <li>通过区块头验证区块在最长链上</li>
                </ul>
            </li>
        </ol>
    </div>
    
    <h4>12.2 默克尔证明</h4>
    <p>轻节点验证交易只需要O(log n)个哈希值：</p>
    
    <pre><code>验证Tx1在区块中：

需要的证明数据：
- Hash2（Tx1的兄弟节点）
- Hash34（父节点的兄弟节点）

验证过程：
1. 计算 Hash1 = Hash(Tx1)
2. 计算 Hash12 = Hash(Hash1 + Hash2)
3. 计算 Merkle Root = Hash(Hash12 + Hash34)
4. 比对计算出的默克尔根与区块头中的默克尔根
5. 如果匹配，证明Tx1确实在区块中</code></pre>
    
    <h3>13. 区块链浏览器</h3>
    
    <h4>13.1 功能</h4>
    <p>区块链浏览器是查看区块链数据的web工具，可以：</p>
    <ul>
        <li>查看任意区块的详细信息</li>
        <li>追踪交易状态</li>
        <li>查看地址余额和交易历史</li>
        <li>监控网络统计数据（难度、算力、手续费等）</li>
    </ul>
    
    <h4>13.2 常用浏览器</h4>
    <ul>
        <li>Blockchain.com</li>
        <li>Blockchair.com</li>
        <li>BTC.com</li>
        <li>Mempool.space（开源）</li>
    </ul>
    
    <h3>14. 总结</h3>
    
    <p>区块链是比特币的核心数据结构，通过巧妙的设计实现了：</p>
    
    <div class="success-box">
        <h4><i class="fas fa-check-circle"></i> 区块链关键特性</h4>
        <ul>
            <li><strong>防篡改</strong>：链式结构+工作量证明</li>
            <li><strong>可验证</strong>：默克尔树提供高效证明</li>
            <li><strong>去中心化</strong>：每个节点独立验证</li>
            <li><strong>有序性</strong>：时间戳+区块高度</li>
            <li><strong>最终一致性</strong>：最长链规则+重组机制</li>
        </ul>
    </div>
    
    <p><strong>核心概念回顾：</strong></p>
    <ul>
        <li>区块由区块头（80字节）和交易列表组成</li>
        <li>区块头包含前一区块哈希，形成链式结构</li>
        <li>默克尔树高效组织和验证交易</li>
        <li>工作量证明使篡改成本极高</li>
        <li>节点通过最长链规则达成共识</li>
        <li>轻节点可以通过SPV进行简化验证</li>
    </ul>
    
    <p>要深入理解区块链的安全性，建议继续学习<strong>密码学原理</strong>和<strong>共识机制</strong>。要了解区块链上记录什么，请学习<strong>交易系统</strong>。</p>
    
    <button class="back-button" onclick="goHome()"><i class="fas fa-arrow-left"></i> 返回首页</button>
</div>
