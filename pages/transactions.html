<div class="page-content">
    <button class="back-button" onclick="goHome()"><i class="fas fa-arrow-left"></i> 返回首页</button>
    
    <h2>比特币交易系统详解</h2>
    
    <p>交易是比特币的核心功能，理解交易结构和验证机制是掌握比特币的关键。</p>
    
    <h3>1. 交易概述</h3>
    
    <h4>1.1 什么是比特币交易？</h4>
    <p>比特币交易不是简单的"从A账户转账到B账户"。它是一个数据结构，包含：</p>
    <ul>
        <li><strong>输入（Inputs）</strong>：引用之前交易的输出，证明你有币可花</li>
        <li><strong>输出（Outputs）</strong>：创建新的币，指定接收方</li>
        <li><strong>元数据</strong>：版本号、锁定时间等</li>
    </ul>
    
    <div class="info-box">
        <h4>通俗理解</h4>
        <p>想象现金交易：</p>
        <ul>
            <li>你掏出一张100元纸币（输入）</li>
            <li>买了60元的东西</li>
            <li>商家收到60元（输出1）</li>
            <li>你收到40元找零（输出2）</li>
            <li>原来的100元纸币被"销毁"，产生了两张新"纸币"</li>
        </ul>
    </div>
    
    <h4>1.2 UTXO模型</h4>
    <p>比特币使用<strong>UTXO（Unspent Transaction Output，未花费交易输出）</strong>模型，而非账户余额模型。</p>
    
    <pre><code>// 账户模型（银行、以太坊）
账户A: 余额100
账户B: 余额50
A转10给B：A-10, B+10
结果：A=90, B=60

// UTXO模型（比特币）
UTXO1: 60 BTC (属于Alice)
UTXO2: 40 BTC (属于Alice)
Alice转50给Bob：
- 输入: UTXO1 (60 BTC)
- 输出1: 50 BTC (给Bob)
- 输出2: 9.99 BTC (找零给Alice)
- 手续费: 0.01 BTC (给矿工)
结果：
- UTXO1被销毁
- 产生两个新UTXO</code></pre>
    
    <div class="info-box">
        <h4>UTXO的优势</h4>
        <ul>
            <li><strong>并行验证</strong>：每个UTXO独立，可并行处理</li>
            <li><strong>隐私性更好</strong>：每次交易可以用新地址接收找零</li>
            <li><strong>简化验证</strong>：只需检查UTXO是否存在且未花费</li>
            <li><strong>防双花</strong>：UTXO只能花费一次</li>
        </ul>
    </div>
    
    <h3>2. 交易结构详解</h3>
    
    <h4>2.1 完整交易结构</h4>
    
    <pre><code>{
  "version": 2,
  "locktime": 0,
  "vin": [
    {
      "txid": "前一笔交易的ID",
      "vout": 0,  // 引用前一笔交易的第几个输出
      "scriptSig": "解锁脚本",
      "sequence": 0xFFFFFFFF
    }
  ],
  "vout": [
    {
      "value": 0.5,  // BTC数量
      "scriptPubKey": "锁定脚本"
    },
    {
      "value": 0.499,  // 找零
      "scriptPubKey": "找零地址的锁定脚本"
    }
  ]
}</code></pre>
    
    <h4>2.2 输入（Input）详解</h4>
    
    <p><strong>① txid (Transaction ID)</strong></p>
    <p>引用之前某笔交易的ID（该交易的哈希值）</p>
    
    <p><strong>② vout (Output Index)</strong></p>
    <p>指定引用那笔交易的第几个输出（从0开始）</p>
    
    <div class="example-box">
        <h4>UTXO引用示例</h4>
        <pre><code>前一笔交易ID: abc123...
该交易有3个输出:
- vout 0: 1 BTC (给Alice)
- vout 1: 0.5 BTC (给Bob)
- vout 2: 0.3 BTC (找零)

现在Alice要花费她的1 BTC:
输入引用: txid=abc123..., vout=0</code></pre>
    </div>
    
    <p><strong>③ scriptSig (解锁脚本)</strong></p>
    <p>证明你有权花费这个UTXO，通常包含：</p>
    <ul>
        <li>数字签名</li>
        <li>公钥</li>
    </ul>
    
    <p><strong>④ sequence</strong></p>
    <p>序列号，用于：</p>
    <ul>
        <li>交易替换（RBF - Replace-By-Fee）</li>
        <li>时间锁定</li>
        <li>通常设为0xFFFFFFFF（最大值，表示最终版本）</li>
    </ul>
    
    <h4>2.3 输出（Output）详解</h4>
    
    <p><strong>① value</strong></p>
    <p>输出金额，单位是<strong>聪（satoshi）</strong>，1 BTC = 10^8 satoshi</p>
    
    <pre><code>// 金额表示
0.5 BTC = 50,000,000 satoshi
0.00001 BTC = 1,000 satoshi
最小单位: 1 satoshi = 0.00000001 BTC</code></pre>
    
    <p><strong>② scriptPubKey (锁定脚本)</strong></p>
    <p>定义花费条件，指定谁可以使用这个输出。</p>
    
    <h3>3. 交易的生命周期</h3>
    
    <h4>3.1 创建交易</h4>
    
    <pre><code>// 创建交易的步骤（伪代码）

1. 选择UTXO
   - 计算需要的总额（金额 + 手续费）
   - 从钱包中选择足够的UTXO
   
   例如：要发送1 BTC，手续费0.0001 BTC
   选择UTXO：0.6 BTC + 0.5 BTC = 1.1 BTC

2. 构建输入
   inputs = []
   for utxo in selected_utxos:
       input = {
           "txid": utxo.txid,
           "vout": utxo.vout,
           "scriptSig": "",  // 暂时留空，签名后填入
           "sequence": 0xFFFFFFFF
       }
       inputs.append(input)

3. 构建输出
   outputs = [
       {
           "value": 1.0,  // 给接收方
           "scriptPubKey": create_p2pkh_script(recipient_address)
       },
       {
           "value": 0.0999,  // 找零 = 1.1 - 1 - 0.0001
           "scriptPubKey": create_p2pkh_script(change_address)
       }
   ]

4. 组装交易
   transaction = {
       "version": 2,
       "vin": inputs,
       "vout": outputs,
       "locktime": 0
   }

5. 签名
   for i, input in enumerate(inputs):
       signature = sign(transaction, i, private_key)
       input["scriptSig"] = create_scriptsig(signature, public_key)

6. 序列化
   raw_tx = serialize(transaction)

7. 广播
   broadcast_to_network(raw_tx)</code></pre>
    
    <h4>3.2 广播到网络</h4>
    <p>交易创建后：</p>
    <ol>
        <li>发送到一个或多个比特币节点</li>
        <li>节点验证交易有效性</li>
        <li>如果有效，加入内存池（Mempool）</li>
        <li>转发给其他节点</li>
        <li>等待矿工打包进区块</li>
    </ol>
    
    <h4>3.3 进入内存池</h4>
    <p>内存池（Mempool）是每个节点维护的待确认交易集合：</p>
    <ul>
        <li>交易在此排队等待确认</li>
        <li>矿工从内存池选择交易打包</li>
        <li>通常按手续费率排序</li>
        <li>网络拥堵时，内存池会积压大量交易</li>
    </ul>
    
    <h4>3.4 确认</h4>
    <p>交易被包含在区块中后，获得第一个确认。每产生一个新区块，确认数+1。</p>
    
    <div class="info-box">
        <h4>确认数的意义</h4>
        <ul>
            <li><strong>0确认</strong>：仅在内存池，未确认</li>
            <li><strong>1确认</strong>：在最新区块中</li>
            <li><strong>6确认</strong>：在6个区块前，基本不可逆（行业标准）</li>
            <li><strong>100确认</strong>：Coinbase交易要求的确认数</li>
        </ul>
    </div>
    
    <h3>4. 交易验证</h3>
    
    <h4>4.1 验证流程</h4>
    
    <div class="example-box">
        <h4>节点验证交易的检查清单</h4>
        <pre><code>1. 格式检查
   □ 交易大小合理（< 100 KB标准交易）
   □ 至少有一个输入和一个输出
   □ 每个输出金额 > 0 且 < 2100万BTC
   
2. 输入验证
   对每个输入：
   □ 引用的UTXO存在
   □ UTXO尚未被花费（防双花）
   □ 解锁脚本正确执行
   □ 签名有效
   
3. 输出验证
   □ 输出总额 ≤ 输入总额
   □ 手续费合理（不能为负）
   
4. 脚本验证
   对每个输入：
   □ 执行 scriptSig + scriptPubKey
   □ 结果必须为TRUE
   
5. 双花检查
   □ 该UTXO未在内存池的其他交易中被引用
   
6. 其他规则
   □ 时间锁定条件满足
   □ 不是dust交易（金额太小）
   □ 符合标准交易规则</code></pre>
    </div>
    
    <h4>4.2 脚本验证详解</h4>
    
    <p>比特币使用脚本语言验证交易。对每个输入：</p>
    
    <pre><code>// 标准P2PKH交易的验证

输入的scriptSig:
<signature> <public_key>

输出的scriptPubKey:
OP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG

验证过程：
1. 将scriptSig和scriptPubKey拼接
   <signature> <public_key> OP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG

2. 使用栈执行：
   步骤1: 入栈 <signature>
   步骤2: 入栈 <public_key>
   步骤3: OP_DUP - 复制栈顶 <public_key>
   步骤4: OP_HASH160 - 哈希栈顶
   步骤5: 入栈 <pubkey_hash>
   步骤6: OP_EQUALVERIFY - 比较两个哈希，相等继续，不等则失败
   步骤7: OP_CHECKSIG - 验证签名
   
3. 如果所有操作成功，验证通过</code></pre>
    
    <h3>5. 交易类型</h3>
    
    <h4>5.1 P2PKH (Pay-to-PubKey-Hash)</h4>
    <p>最常见的交易类型，支付到公钥哈希：</p>
    
    <pre><code>scriptPubKey: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
scriptSig: <signature> <pubKey>

特点：
- 地址以1开头
- 最传统的交易类型
- 公钥不直接暴露，只暴露哈希</code></pre>
    
    <h4>5.2 P2SH (Pay-to-Script-Hash)</h4>
    <p>支付到脚本哈希，支持复杂功能（如多签）：</p>
    
    <pre><code>scriptPubKey: OP_HASH160 <scriptHash> OP_EQUAL
scriptSig: <data> <redeemScript>

特点：
- 地址以3开头
- 支持多重签名
- 支持复杂条件
- 将脚本复杂度从发送方转移到接收方</code></pre>
    
    <h4>5.3 P2WPKH (Pay-to-Witness-PubKey-Hash)</h4>
    <p>SegWit原生地址，隔离见证版本的P2PKH：</p>
    
    <pre><code>scriptPubKey: OP_0 <pubKeyHash>
witness: <signature> <pubKey>

特点：
- 地址以bc1q开头（Bech32格式）
- 交易费更低（折扣）
- 签名不在scriptSig，在witness字段</code></pre>
    
    <h4>5.4 P2TR (Pay-to-Taproot)</h4>
    <p>Taproot地址，最新的地址类型：</p>
    
    <pre><code>特点：
- 地址以bc1p开头
- 支持Schnorr签名
- 更好的隐私性
- 更高效的多签和智能合约</code></pre>
    
    <h3>6. 手续费机制</h3>
    
    <h4>6.1 手续费计算</h4>
    
    <pre><code>手续费 = 输入总额 - 输出总额

例如：
输入：1.5 BTC
输出1：1.0 BTC（给接收方）
输出2：0.4999 BTC（找零）
手续费：1.5 - 1.0 - 0.4999 = 0.0001 BTC

注意：手续费不需要显式声明，是隐含的
如果算错，多余的部分全部给矿工！</code></pre>
    
    <h4>6.2 手续费率</h4>
    
    <p>手续费按交易大小（字节）计算，而非金额：</p>
    
    <pre><code>手续费率 = 手续费 / 交易大小（字节）

单位：satoshi/byte 或 sat/vByte

示例：
交易大小：250 bytes
手续费：0.00005 BTC = 5000 satoshi
费率：5000 / 250 = 20 sat/byte

当前费率参考（2024）：
- 低优先级：1-5 sat/vB（可能等待数小时）
- 中优先级：10-20 sat/vB（通常30-60分钟）
- 高优先级：30-50 sat/vB（下一个区块）
- 紧急：50+ sat/vB（尽快确认）

网络拥堵时费率会飙升到100+ sat/vB</code></pre>
    
    <h4>6.3 交易大小估算</h4>
    
    <pre><code>// 标准P2PKH交易大小估算

固定部分：10 bytes（版本、输入输出数量、locktime）

每个输入：~148 bytes
- txid: 32 bytes
- vout: 4 bytes
- scriptSig: ~107 bytes（签名+公钥）
- sequence: 4 bytes

每个输出：~34 bytes
- value: 8 bytes
- scriptPubKey: ~25 bytes

公式：
交易大小 ≈ 10 + (输入数 × 148) + (输出数 × 34)

例如（1输入2输出）：
大小 = 10 + (1 × 148) + (2 × 34) = 226 bytes

SegWit交易更小（约30%折扣）：
P2WPKH: ~110 bytes/输入
总大小（1输入2输出）≈ 140 vBytes</code></pre>
    
    <h4>6.4 动态手续费策略</h4>
    
    <p>钱包通常提供多档费率：</p>
    <ul>
        <li><strong>经济</strong>：低费率，慢速确认</li>
        <li><strong>正常</strong>：中等费率，合理时间</li>
        <li><strong>优先</strong>：高费率，快速确认</li>
    </ul>
    
    <div class="info-box">
        <h4>费率估算API</h4>
        <p>许多服务提供实时费率估算：</p>
        <ul>
            <li>mempool.space API</li>
            <li>Bitcoin Core estimatesmartfee</li>
            <li>blockchain.info fees</li>
        </ul>
    </div>
    
    <h3>7. 特殊交易功能</h3>
    
    <h4>7.1 RBF (Replace-By-Fee)</h4>
    <p>允许用更高手续费的交易替换未确认的交易：</p>
    
    <pre><code>使用场景：
1. 发送交易时手续费设置过低
2. 交易长时间未确认
3. 创建一个新交易，引用相同的UTXO，提高手续费
4. 广播新交易，矿工会优先打包费率更高的

启用方法：
设置sequence < 0xFFFFFFFE（通常是0xFFFFFFFD）

注意：
- 不是所有钱包都支持
- 接收方看到0确认时要小心（可能被替换）</code></pre>
    
    <h4>7.2 CPFP (Child-Pays-For-Parent)</h4>
    <p>通过创建子交易，激励矿工确认父交易：</p>
    
    <pre><code>场景：
- Alice发送交易A给Bob，手续费太低
- Bob急需确认，但无法修改交易A（不是他的交易）
- Bob创建交易B，花费交易A的输出，设置高手续费
- 矿工要打包交易B，必须先打包交易A
- 矿工会计算总手续费，一起打包

总收益 = 交易A手续费 + 交易B手续费</code></pre>
    
    <h4>7.3 时间锁定</h4>
    
    <p><strong>① nLockTime</strong></p>
    <p>交易级别的时间锁，指定交易在某个时间/区块高度前不能被打包：</p>
    
    <pre><code>locktime值：
< 500,000,000: 区块高度
≥ 500,000,000: Unix时间戳

例如：
locktime = 750000: 区块750000之后才能确认
locktime = 1700000000: 2023年11月15日之后才能确认</code></pre>
    
    <p><strong>② nSequence相对时间锁（BIP68）</strong></p>
    <p>相对于输入UTXO被确认的时间：</p>
    
    <pre><code>用途：
- 闪电网络的惩罚交易
- 时间锁定智能合约

sequence值编码：
bit 31: 禁用标志
bit 22: 类型（0=区块数，1=秒数）
bit 0-15: 数值

例如：
sequence = 10: UTXO确认后10个区块才能使用
sequence = 0x00400010: UTXO确认后512秒才能使用</code></pre>
    
    <h3>8. 交易隐私</h3>
    
    <h4>8.1 地址重用问题</h4>
    
    <div class="warning-box">
        <h4><i class="fas fa-exclamation-triangle"></i> 不要重用地址！</h4>
        <p>多次使用同一地址会：</p>
        <ul>
            <li>降低隐私：所有交易可关联</li>
            <li>降低安全：多次暴露公钥</li>
            <li>便于追踪：区块链分析</li>
        </ul>
        <p><strong>最佳实践</strong>：每次接收都用新地址（HD钱包自动实现）</p>
    </div>
    
    <h4>8.2 CoinJoin</h4>
    <p>多个用户合作创建一笔交易，混淆输入输出的对应关系：</p>
    
    <pre><code>普通交易：
Alice -> Bob (1 BTC)
很明显Alice付给Bob

CoinJoin交易：
Alice + Carol + Eve 的输入 -> Bob + David + Frank 的输出
无法确定谁付给谁

工具：
- Wasabi Wallet
- Samourai Wallet（Whirlpool）
- JoinMarket</code></pre>
    
    <h4>8.3 找零地址</h4>
    <p>使用新地址接收找零，防止关联：</p>
    
    <pre><code>不良实践：
输入：地址A (10 BTC)
输出1：地址B (3 BTC) - 付款
输出2：地址A (6.99 BTC) - 找零回原地址
→ 容易识别地址A是找零

良好实践：
输入：地址A (10 BTC)
输出1：地址B (3 BTC) - 付款
输出2：地址C (6.99 BTC) - 找零到新地址
→ 更难追踪</code></pre>
    
    <h3>9. 交易优化</h3>
    
    <h4>9.1 UTXO管理</h4>
    
    <p>钱包中有很多小额UTXO会增加交易费：</p>
    
    <pre><code>情况A：
拥有1个UTXO (10 BTC)
发送5 BTC：
- 1个输入
- 2个输出
- 交易大小：~226 bytes

情况B：
拥有10个UTXO (每个1 BTC)
发送5 BTC：
- 5个输入（需要花费5个UTXO）
- 2个输出
- 交易大小：~770 bytes
- 费用是情况A的3.4倍！

建议：
- 定期合并小额UTXO（在费率低时）
- 避免接收过多小额支付</code></pre>
    
    <h4>9.2 批量支付</h4>
    
    <p>一笔交易可以有多个输出，节省费用：</p>
    
    <pre><code>单独支付3人：
交易1：1输入2输出（226 bytes）
交易2：1输入2输出（226 bytes）
交易3：1输入2输出（226 bytes）
总计：678 bytes

批量支付3人：
交易：1输入4输出（262 bytes）
节省：61% 的交易空间和费用！

交易所和支付处理商常用此技术</code></pre>
    
    <h4>9.3 SegWit优势</h4>
    
    <pre><code>使用SegWit地址可节省费用：

Legacy (P2PKH): ~148 bytes/输入
SegWit (P2WPKH): ~68 vBytes/输入

节省：约54%

建议：使用原生SegWit地址（bc1开头）</code></pre>
    
    <h3>10. 交易示例</h3>
    
    <h4>10.1 简单支付交易</h4>
    
    <pre><code>{
  "txid": "abc123...",
  "version": 2,
  "locktime": 0,
  "vin": [
    {
      "txid": "def456...",
      "vout": 0,
      "scriptSig": {
        "asm": "3045022100... 03ab12..."
      },
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 1.00000000,
      "n": 0,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 89abc... OP_EQUALVERIFY OP_CHECKSIG",
        "address": "1DaBC..."
      }
    },
    {
      "value": 0.99950000,
      "n": 1,
      "scriptPubKey": {
        "asm": "OP_DUP OP_HASH160 12def... OP_EQUALVERIFY OP_CHECKSIG",
        "address": "1XyZ..."
      }
    }
  ],
  "size": 226,
  "weight": 904
}</code></pre>
    
    <h3>11. 总结</h3>
    
    <div class="success-box">
        <h4><i class="fas fa-check-circle"></i> 核心要点</h4>
        <ul>
            <li><strong>UTXO模型</strong>：比特币不是账户余额，而是未花费输出的集合</li>
            <li><strong>输入引用输出</strong>：每笔交易花费之前的UTXO，创建新的UTXO</li>
            <li><strong>脚本验证</strong>：通过执行脚本证明有权花费</li>
            <li><strong>手续费</strong>：按交易大小计费，不是金额</li>
            <li><strong>确认机制</strong>：6个确认被认为安全</li>
            <li><strong>隐私保护</strong>：不重用地址，使用CoinJoin</li>
            <li><strong>优化策略</strong>：使用SegWit，批量支付，管理UTXO</li>
        </ul>
    </div>
    
    <p>理解交易机制后，你将能更好地使用比特币，并深入学习<strong>脚本系统</strong>和<strong>钱包技术</strong>。</p>
    
    <button class="back-button" onclick="goHome()"><i class="fas fa-arrow-left"></i> 返回首页</button>
</div>
